--------------------------------------------------------------------------------
-- Entity: my_timer_core_regs
-- Description: Register bank with software/hardware access interface
-- Generated by ipcore_lib VHDL Generator
--
-- This is a bus-agnostic register bank that provides:
-- - Register storage for SW-writable registers
-- - Pulse generation for write-1-to-clear fields
-- - Clean interface for hardware logic access
--
-- Connect to a bus wrapper (AXI-Lite, Avalon-MM, etc.) for host access.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.my_timer_core_pkg.all;

entity my_timer_core_regs is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

    -- Write interface (from bus wrapper)
    wr_en   : in  std_logic;
    wr_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    wr_data : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wr_strb : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);

    -- Read interface (from bus wrapper)
    rd_en   : in  std_logic;
    rd_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    rd_data : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    rd_valid: out std_logic;

    -- Register interface to core logic
    regs_out : out t_regs_sw2hw;  -- SW-writable registers (to core)
    regs_in  : in  t_regs_hw2sw   -- HW-writable registers (from core)
  );
end entity my_timer_core_regs;

architecture rtl of my_timer_core_regs is

  -- Internal register storage
  signal regs : t_regs_sw2hw := C_REGS_SW2HW_RESET;

  -- Read data pipeline
  signal rd_data_int  : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal rd_valid_int : std_logic;

  -- Apply write strobe to data
  function apply_wstrb(
    old_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    new_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wstrb    : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0)
  ) return std_logic_vector is
    variable result : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    for i in 0 to (C_DATA_WIDTH/8)-1 loop
      if wstrb(i) = '1' then
        result(i*8+7 downto i*8) := new_data(i*8+7 downto i*8);
      else
        result(i*8+7 downto i*8) := old_data(i*8+7 downto i*8);
      end if;
    end loop;
    return result;
  end function;

begin

  -- Output register values to core
  regs_out <= regs;
  rd_data  <= rd_data_int;
  rd_valid <= rd_valid_int;

  ----------------------------------------------------------------------------
  -- Write Process
  ----------------------------------------------------------------------------
  p_write : process(clk)
    variable v_addr_index : natural;
    variable v_wdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    if rising_edge(clk) then
      if rst = '1' then
        regs <= C_REGS_SW2HW_RESET;
      elsif wr_en = '1' then
        v_addr_index := to_integer(unsigned(wr_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
          when t_reg_id'pos(REG_GLOBAL_CTRL) =>
            v_wdata := apply_wstrb(to_slv(regs.global_ctrl), wr_data, wr_strb);
            regs.global_ctrl <= to_global_ctrl(v_wdata);
          when t_reg_id'pos(REG_SCRATCHPAD_USER) =>
            v_wdata := apply_wstrb(to_slv(regs.scratchpad_user), wr_data, wr_strb);
            regs.scratchpad_user <= to_scratchpad_user(v_wdata);
          when t_reg_id'pos(REG_TIMER_0_CTRL) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_0_ctrl), wr_data, wr_strb);
            regs.timer_0_ctrl <= to_timer_0_ctrl(v_wdata);
          when t_reg_id'pos(REG_TIMER_0_PERIOD) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_0_period), wr_data, wr_strb);
            regs.timer_0_period <= to_timer_0_period(v_wdata);
          when t_reg_id'pos(REG_TIMER_1_CTRL) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_1_ctrl), wr_data, wr_strb);
            regs.timer_1_ctrl <= to_timer_1_ctrl(v_wdata);
          when t_reg_id'pos(REG_TIMER_1_PERIOD) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_1_period), wr_data, wr_strb);
            regs.timer_1_period <= to_timer_1_period(v_wdata);
          when t_reg_id'pos(REG_TIMER_2_CTRL) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_2_ctrl), wr_data, wr_strb);
            regs.timer_2_ctrl <= to_timer_2_ctrl(v_wdata);
          when t_reg_id'pos(REG_TIMER_2_PERIOD) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_2_period), wr_data, wr_strb);
            regs.timer_2_period <= to_timer_2_period(v_wdata);
          when t_reg_id'pos(REG_TIMER_3_CTRL) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_3_ctrl), wr_data, wr_strb);
            regs.timer_3_ctrl <= to_timer_3_ctrl(v_wdata);
          when t_reg_id'pos(REG_TIMER_3_PERIOD) =>
            v_wdata := apply_wstrb(to_slv(regs.timer_3_period), wr_data, wr_strb);
            regs.timer_3_period <= to_timer_3_period(v_wdata);
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;

  ----------------------------------------------------------------------------
  -- Read Process
  ----------------------------------------------------------------------------
  p_read : process(clk)
    variable v_addr_index : natural;
  begin
    if rising_edge(clk) then
      rd_valid_int <= '0';

      if rst = '1' then
        rd_data_int  <= (others => '0');
        rd_valid_int <= '0';
      elsif rd_en = '1' then
        v_addr_index := to_integer(unsigned(rd_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
          when t_reg_id'pos(REG_GLOBAL_CTRL) =>
            rd_data_int <= to_slv(regs.global_ctrl);
          when t_reg_id'pos(REG_GLOBAL_STATUS) =>
            rd_data_int <= to_slv(regs_in.global_status);
          when t_reg_id'pos(REG_SCRATCHPAD_USER) =>
            rd_data_int <= to_slv(regs.scratchpad_user);
          when t_reg_id'pos(REG_TIMER_0_CTRL) =>
            rd_data_int <= to_slv(regs.timer_0_ctrl);
          when t_reg_id'pos(REG_TIMER_0_PERIOD) =>
            rd_data_int <= to_slv(regs.timer_0_period);
          when t_reg_id'pos(REG_TIMER_0_VALUE) =>
            rd_data_int <= to_slv(regs_in.timer_0_value);
          when t_reg_id'pos(REG_TIMER_1_CTRL) =>
            rd_data_int <= to_slv(regs.timer_1_ctrl);
          when t_reg_id'pos(REG_TIMER_1_PERIOD) =>
            rd_data_int <= to_slv(regs.timer_1_period);
          when t_reg_id'pos(REG_TIMER_1_VALUE) =>
            rd_data_int <= to_slv(regs_in.timer_1_value);
          when t_reg_id'pos(REG_TIMER_2_CTRL) =>
            rd_data_int <= to_slv(regs.timer_2_ctrl);
          when t_reg_id'pos(REG_TIMER_2_PERIOD) =>
            rd_data_int <= to_slv(regs.timer_2_period);
          when t_reg_id'pos(REG_TIMER_2_VALUE) =>
            rd_data_int <= to_slv(regs_in.timer_2_value);
          when t_reg_id'pos(REG_TIMER_3_CTRL) =>
            rd_data_int <= to_slv(regs.timer_3_ctrl);
          when t_reg_id'pos(REG_TIMER_3_PERIOD) =>
            rd_data_int <= to_slv(regs.timer_3_period);
          when t_reg_id'pos(REG_TIMER_3_VALUE) =>
            rd_data_int <= to_slv(regs_in.timer_3_value);
          when others =>
            rd_data_int <= (others => '0');
        end case;

        rd_valid_int <= '1';
      end if;
    end if;
  end process;

end architecture rtl;