--------------------------------------------------------------------------------
-- Package: my_timer_core_pkg
-- Generated by ipcore_lib VHDL Generator
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package my_timer_core_pkg is

  ----------------------------------------------------------------------------
  -- Constants
  ----------------------------------------------------------------------------
  constant C_DATA_WIDTH : natural := 32;
  constant C_ADDR_WIDTH : natural := 8;
  constant C_REG_WIDTH  : natural := 4;  -- Bytes per register

  ----------------------------------------------------------------------------
  -- Register Enumeration (Order defines address)
  ----------------------------------------------------------------------------
  type t_reg_id is (
    REG_GLOBAL_CTRL,  -- addr 0x00
    REG_GLOBAL_STATUS,  -- addr 0x04
    REG_SCRATCHPAD_USER,  -- addr 0x08
    REG_TIMER_0_CTRL,  -- addr 0x0C
    REG_TIMER_0_STATUS,  -- addr 0x10
    REG_TIMER_0_PERIOD,  -- addr 0x14
    REG_TIMER_0_VALUE,  -- addr 0x18
    REG_TIMER_1_CTRL,  -- addr 0x1C
    REG_TIMER_1_STATUS,  -- addr 0x20
    REG_TIMER_1_PERIOD,  -- addr 0x24
    REG_TIMER_1_VALUE,  -- addr 0x28
    REG_TIMER_2_CTRL,  -- addr 0x2C
    REG_TIMER_2_STATUS,  -- addr 0x30
    REG_TIMER_2_PERIOD,  -- addr 0x34
    REG_TIMER_2_VALUE,  -- addr 0x38
    REG_TIMER_3_CTRL,  -- addr 0x3C
    REG_TIMER_3_STATUS,  -- addr 0x40
    REG_TIMER_3_PERIOD,  -- addr 0x44
    REG_TIMER_3_VALUE  -- addr 0x48
  );

  -- Calculate register address from enumeration
  function reg_addr(reg : t_reg_id) return natural;

  ----------------------------------------------------------------------------
  -- Register Record Types
  ----------------------------------------------------------------------------

  -- GLOBAL_CTRL register fields
  type t_reg_global_ctrl is record
    enable_all : std_logic;  -- bit 0
    mode_select : std_logic_vector(1 downto 0);  -- bits 2:1
    irq_enable : std_logic_vector(1 downto 0);  -- bits 4:3
    reset_all : std_logic_vector(3 downto 0);  -- bits 8:5
    debug_freeze : std_logic_vector(3 downto 0);  -- bits 12:9
    prescale : std_logic_vector(2 downto 0);  -- bits 15:13
    auto_reload : std_logic;  -- bit 16
    wakeup_enable : std_logic_vector(1 downto 0);  -- bits 18:17
    force_irq : std_logic;  -- bit 19
    reserved : std_logic_vector(11 downto 0);  -- bits 31:20
  end record;

  constant C_REG_GLOBAL_CTRL_RESET : t_reg_global_ctrl := (
    enable_all => '0',
    mode_select => (others => '0'),
    irq_enable => (others => '0'),
    reset_all => (others => '0'),
    debug_freeze => (others => '0'),
    prescale => (others => '0'),
    auto_reload => '0',
    wakeup_enable => (others => '0'),
    force_irq => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_global_ctrl) return std_logic_vector;
  function to_global_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_global_ctrl;

  -- GLOBAL_STATUS register fields
  type t_reg_global_status is record
    irq_pending : std_logic;  -- bit 0
    reserved : std_logic_vector(30 downto 0);  -- bits 31:1
  end record;

  constant C_REG_GLOBAL_STATUS_RESET : t_reg_global_status := (
    irq_pending => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_global_status) return std_logic_vector;
  function to_global_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_global_status;

  -- SCRATCHPAD_USER register fields
  type t_reg_scratchpad_user is record
    data : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_SCRATCHPAD_USER_RESET : t_reg_scratchpad_user := (
    data => (others => '0')
  );

  function to_slv(reg : t_reg_scratchpad_user) return std_logic_vector;
  function to_scratchpad_user(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_scratchpad_user;

  -- TIMER_0_CTRL register fields
  type t_reg_timer_0_ctrl is record
    enable : std_logic;  -- bit 0
    mode : std_logic;  -- bit 1
    ie : std_logic;  -- bit 2
    reserved : std_logic_vector(28 downto 0);  -- bits 31:3
  end record;

  constant C_REG_TIMER_0_CTRL_RESET : t_reg_timer_0_ctrl := (
    enable => '0',
    mode => '0',
    ie => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_0_ctrl) return std_logic_vector;
  function to_timer_0_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_ctrl;

  -- TIMER_0_STATUS register fields
  type t_reg_timer_0_status is record
    irq_pending : std_logic;  -- bit 0
    reserved : std_logic_vector(30 downto 0);  -- bits 31:1
  end record;

  constant C_REG_TIMER_0_STATUS_RESET : t_reg_timer_0_status := (
    irq_pending => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_0_status) return std_logic_vector;
  function to_timer_0_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_status;

  -- TIMER_0_PERIOD register fields
  type t_reg_timer_0_period is record
    period_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_0_PERIOD_RESET : t_reg_timer_0_period := (
    period_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_0_period) return std_logic_vector;
  function to_timer_0_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_period;

  -- TIMER_0_VALUE register fields
  type t_reg_timer_0_value is record
    current_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_0_VALUE_RESET : t_reg_timer_0_value := (
    current_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_0_value) return std_logic_vector;
  function to_timer_0_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_value;

  -- TIMER_1_CTRL register fields
  type t_reg_timer_1_ctrl is record
    enable : std_logic;  -- bit 0
    mode : std_logic;  -- bit 1
    ie : std_logic;  -- bit 2
    reserved : std_logic_vector(28 downto 0);  -- bits 31:3
  end record;

  constant C_REG_TIMER_1_CTRL_RESET : t_reg_timer_1_ctrl := (
    enable => '0',
    mode => '0',
    ie => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_1_ctrl) return std_logic_vector;
  function to_timer_1_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_ctrl;

  -- TIMER_1_STATUS register fields
  type t_reg_timer_1_status is record
    irq_pending : std_logic;  -- bit 0
    reserved : std_logic_vector(30 downto 0);  -- bits 31:1
  end record;

  constant C_REG_TIMER_1_STATUS_RESET : t_reg_timer_1_status := (
    irq_pending => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_1_status) return std_logic_vector;
  function to_timer_1_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_status;

  -- TIMER_1_PERIOD register fields
  type t_reg_timer_1_period is record
    period_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_1_PERIOD_RESET : t_reg_timer_1_period := (
    period_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_1_period) return std_logic_vector;
  function to_timer_1_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_period;

  -- TIMER_1_VALUE register fields
  type t_reg_timer_1_value is record
    current_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_1_VALUE_RESET : t_reg_timer_1_value := (
    current_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_1_value) return std_logic_vector;
  function to_timer_1_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_value;

  -- TIMER_2_CTRL register fields
  type t_reg_timer_2_ctrl is record
    enable : std_logic;  -- bit 0
    mode : std_logic;  -- bit 1
    ie : std_logic;  -- bit 2
    reserved : std_logic_vector(28 downto 0);  -- bits 31:3
  end record;

  constant C_REG_TIMER_2_CTRL_RESET : t_reg_timer_2_ctrl := (
    enable => '0',
    mode => '0',
    ie => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_2_ctrl) return std_logic_vector;
  function to_timer_2_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_ctrl;

  -- TIMER_2_STATUS register fields
  type t_reg_timer_2_status is record
    irq_pending : std_logic;  -- bit 0
    reserved : std_logic_vector(30 downto 0);  -- bits 31:1
  end record;

  constant C_REG_TIMER_2_STATUS_RESET : t_reg_timer_2_status := (
    irq_pending => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_2_status) return std_logic_vector;
  function to_timer_2_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_status;

  -- TIMER_2_PERIOD register fields
  type t_reg_timer_2_period is record
    period_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_2_PERIOD_RESET : t_reg_timer_2_period := (
    period_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_2_period) return std_logic_vector;
  function to_timer_2_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_period;

  -- TIMER_2_VALUE register fields
  type t_reg_timer_2_value is record
    current_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_2_VALUE_RESET : t_reg_timer_2_value := (
    current_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_2_value) return std_logic_vector;
  function to_timer_2_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_value;

  -- TIMER_3_CTRL register fields
  type t_reg_timer_3_ctrl is record
    enable : std_logic;  -- bit 0
    mode : std_logic;  -- bit 1
    ie : std_logic;  -- bit 2
    reserved : std_logic_vector(28 downto 0);  -- bits 31:3
  end record;

  constant C_REG_TIMER_3_CTRL_RESET : t_reg_timer_3_ctrl := (
    enable => '0',
    mode => '0',
    ie => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_3_ctrl) return std_logic_vector;
  function to_timer_3_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_ctrl;

  -- TIMER_3_STATUS register fields
  type t_reg_timer_3_status is record
    irq_pending : std_logic;  -- bit 0
    reserved : std_logic_vector(30 downto 0);  -- bits 31:1
  end record;

  constant C_REG_TIMER_3_STATUS_RESET : t_reg_timer_3_status := (
    irq_pending => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_timer_3_status) return std_logic_vector;
  function to_timer_3_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_status;

  -- TIMER_3_PERIOD register fields
  type t_reg_timer_3_period is record
    period_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_3_PERIOD_RESET : t_reg_timer_3_period := (
    period_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_3_period) return std_logic_vector;
  function to_timer_3_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_period;

  -- TIMER_3_VALUE register fields
  type t_reg_timer_3_value is record
    current_value : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_TIMER_3_VALUE_RESET : t_reg_timer_3_value := (
    current_value => (others => '0')
  );

  function to_slv(reg : t_reg_timer_3_value) return std_logic_vector;
  function to_timer_3_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_value;

  ----------------------------------------------------------------------------
  -- Aggregate Register Records (for clean port interface)
  ----------------------------------------------------------------------------

  -- SW -> HW: Registers written by software, read by hardware
  type t_regs_sw2hw is record
    global_ctrl : t_reg_global_ctrl;
    scratchpad_user : t_reg_scratchpad_user;
    timer_0_ctrl : t_reg_timer_0_ctrl;
    timer_0_period : t_reg_timer_0_period;
    timer_1_ctrl : t_reg_timer_1_ctrl;
    timer_1_period : t_reg_timer_1_period;
    timer_2_ctrl : t_reg_timer_2_ctrl;
    timer_2_period : t_reg_timer_2_period;
    timer_3_ctrl : t_reg_timer_3_ctrl;
    timer_3_period : t_reg_timer_3_period;
  end record;

  constant C_REGS_SW2HW_RESET : t_regs_sw2hw := (
    global_ctrl => C_REG_GLOBAL_CTRL_RESET,
    scratchpad_user => C_REG_SCRATCHPAD_USER_RESET,
    timer_0_ctrl => C_REG_TIMER_0_CTRL_RESET,
    timer_0_period => C_REG_TIMER_0_PERIOD_RESET,
    timer_1_ctrl => C_REG_TIMER_1_CTRL_RESET,
    timer_1_period => C_REG_TIMER_1_PERIOD_RESET,
    timer_2_ctrl => C_REG_TIMER_2_CTRL_RESET,
    timer_2_period => C_REG_TIMER_2_PERIOD_RESET,
    timer_3_ctrl => C_REG_TIMER_3_CTRL_RESET,
    timer_3_period => C_REG_TIMER_3_PERIOD_RESET
  );

  -- HW -> SW: Registers written by hardware, read by software
  type t_regs_hw2sw is record
    global_status : t_reg_global_status;
    timer_0_value : t_reg_timer_0_value;
    timer_1_value : t_reg_timer_1_value;
    timer_2_value : t_reg_timer_2_value;
    timer_3_value : t_reg_timer_3_value;
  end record;

  constant C_REGS_HW2SW_RESET : t_regs_hw2sw := (
    global_status => C_REG_GLOBAL_STATUS_RESET,
    timer_0_value => C_REG_TIMER_0_VALUE_RESET,
    timer_1_value => C_REG_TIMER_1_VALUE_RESET,
    timer_2_value => C_REG_TIMER_2_VALUE_RESET,
    timer_3_value => C_REG_TIMER_3_VALUE_RESET
  );

end package my_timer_core_pkg;


package body my_timer_core_pkg is

  ----------------------------------------------------------------------------
  -- Register Address Function
  ----------------------------------------------------------------------------
  function reg_addr(reg : t_reg_id) return natural is
  begin
    return t_reg_id'pos(reg) * C_REG_WIDTH;
  end function;

  ----------------------------------------------------------------------------
  -- Conversion Functions
  ----------------------------------------------------------------------------

  -- GLOBAL_CTRL conversions
  function to_slv(reg : t_reg_global_ctrl) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable_all;
    slv(2 downto 1) := reg.mode_select;
    slv(4 downto 3) := reg.irq_enable;
    slv(8 downto 5) := reg.reset_all;
    slv(12 downto 9) := reg.debug_freeze;
    slv(15 downto 13) := reg.prescale;
    slv(16) := reg.auto_reload;
    slv(18 downto 17) := reg.wakeup_enable;
    slv(19) := reg.force_irq;
    slv(31 downto 20) := reg.reserved;
    return slv;
  end function;

  function to_global_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_global_ctrl is
    variable reg : t_reg_global_ctrl;
  begin
    reg.enable_all := slv(0);
    reg.mode_select := slv(2 downto 1);
    reg.irq_enable := slv(4 downto 3);
    reg.reset_all := slv(8 downto 5);
    reg.debug_freeze := slv(12 downto 9);
    reg.prescale := slv(15 downto 13);
    reg.auto_reload := slv(16);
    reg.wakeup_enable := slv(18 downto 17);
    reg.force_irq := slv(19);
    reg.reserved := slv(31 downto 20);
    return reg;
  end function;

  -- GLOBAL_STATUS conversions
  function to_slv(reg : t_reg_global_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.irq_pending;
    slv(31 downto 1) := reg.reserved;
    return slv;
  end function;

  function to_global_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_global_status is
    variable reg : t_reg_global_status;
  begin
    reg.irq_pending := slv(0);
    reg.reserved := slv(31 downto 1);
    return reg;
  end function;

  -- SCRATCHPAD_USER conversions
  function to_slv(reg : t_reg_scratchpad_user) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.data;
    return slv;
  end function;

  function to_scratchpad_user(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_scratchpad_user is
    variable reg : t_reg_scratchpad_user;
  begin
    reg.data := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_0_CTRL conversions
  function to_slv(reg : t_reg_timer_0_ctrl) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable;
    slv(1) := reg.mode;
    slv(2) := reg.ie;
    slv(31 downto 3) := reg.reserved;
    return slv;
  end function;

  function to_timer_0_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_ctrl is
    variable reg : t_reg_timer_0_ctrl;
  begin
    reg.enable := slv(0);
    reg.mode := slv(1);
    reg.ie := slv(2);
    reg.reserved := slv(31 downto 3);
    return reg;
  end function;

  -- TIMER_0_STATUS conversions
  function to_slv(reg : t_reg_timer_0_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.irq_pending;
    slv(31 downto 1) := reg.reserved;
    return slv;
  end function;

  function to_timer_0_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_status is
    variable reg : t_reg_timer_0_status;
  begin
    reg.irq_pending := slv(0);
    reg.reserved := slv(31 downto 1);
    return reg;
  end function;

  -- TIMER_0_PERIOD conversions
  function to_slv(reg : t_reg_timer_0_period) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.period_value;
    return slv;
  end function;

  function to_timer_0_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_period is
    variable reg : t_reg_timer_0_period;
  begin
    reg.period_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_0_VALUE conversions
  function to_slv(reg : t_reg_timer_0_value) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.current_value;
    return slv;
  end function;

  function to_timer_0_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_0_value is
    variable reg : t_reg_timer_0_value;
  begin
    reg.current_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_1_CTRL conversions
  function to_slv(reg : t_reg_timer_1_ctrl) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable;
    slv(1) := reg.mode;
    slv(2) := reg.ie;
    slv(31 downto 3) := reg.reserved;
    return slv;
  end function;

  function to_timer_1_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_ctrl is
    variable reg : t_reg_timer_1_ctrl;
  begin
    reg.enable := slv(0);
    reg.mode := slv(1);
    reg.ie := slv(2);
    reg.reserved := slv(31 downto 3);
    return reg;
  end function;

  -- TIMER_1_STATUS conversions
  function to_slv(reg : t_reg_timer_1_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.irq_pending;
    slv(31 downto 1) := reg.reserved;
    return slv;
  end function;

  function to_timer_1_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_status is
    variable reg : t_reg_timer_1_status;
  begin
    reg.irq_pending := slv(0);
    reg.reserved := slv(31 downto 1);
    return reg;
  end function;

  -- TIMER_1_PERIOD conversions
  function to_slv(reg : t_reg_timer_1_period) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.period_value;
    return slv;
  end function;

  function to_timer_1_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_period is
    variable reg : t_reg_timer_1_period;
  begin
    reg.period_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_1_VALUE conversions
  function to_slv(reg : t_reg_timer_1_value) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.current_value;
    return slv;
  end function;

  function to_timer_1_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_1_value is
    variable reg : t_reg_timer_1_value;
  begin
    reg.current_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_2_CTRL conversions
  function to_slv(reg : t_reg_timer_2_ctrl) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable;
    slv(1) := reg.mode;
    slv(2) := reg.ie;
    slv(31 downto 3) := reg.reserved;
    return slv;
  end function;

  function to_timer_2_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_ctrl is
    variable reg : t_reg_timer_2_ctrl;
  begin
    reg.enable := slv(0);
    reg.mode := slv(1);
    reg.ie := slv(2);
    reg.reserved := slv(31 downto 3);
    return reg;
  end function;

  -- TIMER_2_STATUS conversions
  function to_slv(reg : t_reg_timer_2_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.irq_pending;
    slv(31 downto 1) := reg.reserved;
    return slv;
  end function;

  function to_timer_2_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_status is
    variable reg : t_reg_timer_2_status;
  begin
    reg.irq_pending := slv(0);
    reg.reserved := slv(31 downto 1);
    return reg;
  end function;

  -- TIMER_2_PERIOD conversions
  function to_slv(reg : t_reg_timer_2_period) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.period_value;
    return slv;
  end function;

  function to_timer_2_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_period is
    variable reg : t_reg_timer_2_period;
  begin
    reg.period_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_2_VALUE conversions
  function to_slv(reg : t_reg_timer_2_value) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.current_value;
    return slv;
  end function;

  function to_timer_2_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_2_value is
    variable reg : t_reg_timer_2_value;
  begin
    reg.current_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_3_CTRL conversions
  function to_slv(reg : t_reg_timer_3_ctrl) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable;
    slv(1) := reg.mode;
    slv(2) := reg.ie;
    slv(31 downto 3) := reg.reserved;
    return slv;
  end function;

  function to_timer_3_ctrl(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_ctrl is
    variable reg : t_reg_timer_3_ctrl;
  begin
    reg.enable := slv(0);
    reg.mode := slv(1);
    reg.ie := slv(2);
    reg.reserved := slv(31 downto 3);
    return reg;
  end function;

  -- TIMER_3_STATUS conversions
  function to_slv(reg : t_reg_timer_3_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.irq_pending;
    slv(31 downto 1) := reg.reserved;
    return slv;
  end function;

  function to_timer_3_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_status is
    variable reg : t_reg_timer_3_status;
  begin
    reg.irq_pending := slv(0);
    reg.reserved := slv(31 downto 1);
    return reg;
  end function;

  -- TIMER_3_PERIOD conversions
  function to_slv(reg : t_reg_timer_3_period) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.period_value;
    return slv;
  end function;

  function to_timer_3_period(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_period is
    variable reg : t_reg_timer_3_period;
  begin
    reg.period_value := slv(31 downto 0);
    return reg;
  end function;

  -- TIMER_3_VALUE conversions
  function to_slv(reg : t_reg_timer_3_value) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.current_value;
    return slv;
  end function;

  function to_timer_3_value(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_timer_3_value is
    variable reg : t_reg_timer_3_value;
  begin
    reg.current_value := slv(31 downto 0);
    return reg;
  end function;

end package body my_timer_core_pkg;