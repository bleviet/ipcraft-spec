--------------------------------------------------------------------------------
-- Entity: my_timer_core_core
-- Description: Core logic module (bus-agnostic)
-- Generated by ipcore_lib VHDL Generator
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.my_timer_core_pkg.all;

entity my_timer_core_core is
  generic (
    NUM_CHANNELS : integer := 4;
    AXI_ADDR_WIDTH : integer := 32;
    EVENT_FIFO_DEPTH : integer := 16;
    TIMESTAMP_WIDTH : integer := 48
  );
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

    -- Register interface (record-based)
    regs_in : in t_regs_sw2hw; -- SW-writable registers (from bus wrapper)
    regs_out : out t_regs_hw2sw; -- HW-writable registers (to bus wrapper)

    -- Secondary Bus Interfaces
    m_axis_ch0_evt_tdata : out std_logic_vector(63 downto 0);
    m_axis_ch0_evt_tvalid : out std_logic;
    m_axis_ch0_evt_tready : in  std_logic;
    m_axis_ch0_evt_tlast : out std_logic;
    m_axis_ch0_evt_tuser : out std_logic_vector(3 downto 0);
    m_axis_ch1_evt_tdata : out std_logic_vector(63 downto 0);
    m_axis_ch1_evt_tvalid : out std_logic;
    m_axis_ch1_evt_tready : in  std_logic;
    m_axis_ch1_evt_tlast : out std_logic;
    m_axis_ch1_evt_tuser : out std_logic_vector(3 downto 0);
    m_axis_ch2_evt_tdata : out std_logic_vector(63 downto 0);
    m_axis_ch2_evt_tvalid : out std_logic;
    m_axis_ch2_evt_tready : in  std_logic;
    m_axis_ch2_evt_tlast : out std_logic;
    m_axis_ch2_evt_tuser : out std_logic_vector(3 downto 0);
    m_axis_ch3_evt_tdata : out std_logic_vector(63 downto 0);
    m_axis_ch3_evt_tvalid : out std_logic;
    m_axis_ch3_evt_tready : in  std_logic;
    m_axis_ch3_evt_tlast : out std_logic;
    m_axis_ch3_evt_tuser : out std_logic_vector(3 downto 0);

    -- User ports
    o_global_irq : out std_logic
    );
end entity my_timer_core_core;

architecture rtl of my_timer_core_core is

  ----------------------------------------------------------------------------
  -- Internal Signals
  ----------------------------------------------------------------------------
  -- Add your internal signals here

begin

  ----------------------------------------------------------------------------
  -- Main Process
  ----------------------------------------------------------------------------
  p_main : process(clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        -- Reset logic
        regs_out <= C_REGS_HW2SW_RESET;
      else
        -- Example: Access SW-writable register fields
        -- if regs_in.control.enable = '1' then
        --     -- Do something
        -- end if;

        -- Example: Update HW-writable register fields
        -- regs_out.status.busy <= '1';
        null;
      end if;
    end if;
  end process;

end architecture rtl;