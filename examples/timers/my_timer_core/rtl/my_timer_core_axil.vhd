--------------------------------------------------------------------------------
-- Entity: my_timer_core_axil
-- Description: AXI-Lite slave interface for register access
-- Generated by ipcore_lib VHDL Generator
--
-- Register Map:
--   0x0000 : GLOBAL_CTRL (read-write)
--   0x0004 : GLOBAL_STATUS (read-only)
--   0x0008 : SCRATCHPAD_USER (read-write)
--   0x000C : TIMER_0_CTRL (read-write)
--   0x0010 : TIMER_0_STATUS (write-1-to-clear)
--   0x0014 : TIMER_0_PERIOD (read-write)
--   0x0018 : TIMER_0_VALUE (read-only)
--   0x001C : TIMER_1_CTRL (read-write)
--   0x0020 : TIMER_1_STATUS (write-1-to-clear)
--   0x0024 : TIMER_1_PERIOD (read-write)
--   0x0028 : TIMER_1_VALUE (read-only)
--   0x002C : TIMER_2_CTRL (read-write)
--   0x0030 : TIMER_2_STATUS (write-1-to-clear)
--   0x0034 : TIMER_2_PERIOD (read-write)
--   0x0038 : TIMER_2_VALUE (read-only)
--   0x003C : TIMER_3_CTRL (read-write)
--   0x0040 : TIMER_3_STATUS (write-1-to-clear)
--   0x0044 : TIMER_3_PERIOD (read-write)
--   0x0048 : TIMER_3_VALUE (read-only)
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.my_timer_core_pkg.all;

entity my_timer_core_axil is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

    -- AXI-Lite Slave Interface
    s_axi_awaddr   : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    s_axi_awvalid  : in  std_logic;
    s_axi_awready  : out std_logic;
    s_axi_awprot   : in  std_logic_vector(2 downto 0);
    s_axi_wdata    : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    s_axi_wstrb    : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
    s_axi_wvalid   : in  std_logic;
    s_axi_wready   : out std_logic;
    s_axi_bresp    : out std_logic_vector(1 downto 0);
    s_axi_bvalid   : out std_logic;
    s_axi_bready   : in  std_logic;
    s_axi_araddr   : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    s_axi_arvalid  : in  std_logic;
    s_axi_arready  : out std_logic;
    s_axi_arprot   : in  std_logic_vector(2 downto 0);
    s_axi_rdata    : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    s_axi_rresp    : out std_logic_vector(1 downto 0);
    s_axi_rvalid   : out std_logic;
    s_axi_rready   : in  std_logic
    ;

    -- Register interface
    regs_out : out t_regs_sw2hw;  -- To core (SW-writable)
    regs_in  : in  t_regs_hw2sw   -- From core (HW-writable)
  );
end entity my_timer_core_axil;

architecture rtl of my_timer_core_axil is

  -- AXI-Lite response constants
  constant C_RESP_OKAY   : std_logic_vector(1 downto 0) := "00";
  constant C_RESP_SLVERR : std_logic_vector(1 downto 0) := "10";

  -- AXI internal signals
  signal axi_awaddr  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
  signal axi_awready : std_logic                                    := '0';
  signal axi_wready  : std_logic                                    := '0';
  signal axi_bresp   : std_logic_vector(1 downto 0)                 := C_RESP_OKAY;
  signal axi_bvalid  : std_logic                                    := '0';
  signal axi_araddr  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
  signal axi_arready : std_logic                                    := '0';
  signal axi_rdata   : std_logic_vector(C_DATA_WIDTH - 1 downto 0) := (others => '0');
  signal axi_rresp   : std_logic_vector(1 downto 0)                 := C_RESP_OKAY;
  signal axi_rvalid  : std_logic                                    := '0';

  -- Register bank interface signals
  signal wr_en     : std_logic;
  signal wr_addr   : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal wr_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal wr_strb   : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
  signal rd_en     : std_logic;
  signal rd_addr   : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal rd_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal rd_valid  : std_logic;

  -- Write transaction tracking using VHDL 2008 records
  type t_write_transaction is record
    aw_en         : std_logic; -- Address write enable flag
    addr_received : std_logic; -- Address has been received
    data_received : std_logic; -- Data has been received
  end record t_write_transaction;

  signal write_txn : t_write_transaction := ('1', '0', '0');

begin

  ----------------------------------------------------------------------------
  -- Register Bank Instantiation
  ----------------------------------------------------------------------------
  u_regs : entity work.my_timer_core_regs
    port map (
      clk      => clk,
      rst      => rst,
      wr_en    => wr_en,
      wr_addr  => wr_addr,
      wr_data  => wr_data,
      wr_strb  => wr_strb,
      rd_en    => rd_en,
      rd_addr  => rd_addr,
      rd_data  => rd_data,
      rd_valid => rd_valid,
      regs_out => regs_out,
      regs_in  => regs_in
    );

  -- Connect internal AXI signals to ports
  s_axi_awready <= axi_awready;
  s_axi_wready  <= axi_wready;
  s_axi_bresp   <= axi_bresp;
  s_axi_bvalid  <= axi_bvalid;
  s_axi_arready <= axi_arready;
  s_axi_rdata   <= axi_rdata;
  s_axi_rresp   <= axi_rresp;
  s_axi_rvalid  <= axi_rvalid;

  ----------------------------------------------------------------------------
  -- Write Address Channel
  -- Accept write address when AWVALID is asserted (independent of WVALID)
  ----------------------------------------------------------------------------
  write_addr_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_awready             <= '0';
        write_txn.aw_en         <= '1';
        axi_awaddr              <= (others => '0');
        write_txn.addr_received <= '0';
      else
        if (axi_awready = '0' and s_axi_awvalid = '1' and write_txn.aw_en = '1') then
          -- Ready to accept write address
          axi_awready             <= '1';
          write_txn.aw_en         <= '0';
          axi_awaddr              <= s_axi_awaddr;
          write_txn.addr_received <= '1';
        elsif (axi_bvalid = '1' and s_axi_bready = '1') then
          -- Write response completed, ready for next transaction
          write_txn.aw_en         <= '1';
          write_txn.addr_received <= '0';
          axi_awready             <= '0';
        else
          axi_awready <= '0';
        end if;
      end if;
    end if;
  end process write_addr_proc;

  ----------------------------------------------------------------------------
  -- Write Data Channel
  -- Accept write data when WVALID is asserted (independent of AWVALID)
  ----------------------------------------------------------------------------
  write_data_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_wready              <= '0';
        write_txn.data_received <= '0';
      else
        if (axi_wready = '0' and s_axi_wvalid = '1') then
          -- Ready to accept write data
          axi_wready              <= '1';
          write_txn.data_received <= '1';
        elsif (axi_bvalid = '1' and s_axi_bready = '1') then
          -- Write response completed, ready for next transaction
          write_txn.data_received <= '0';
          axi_wready              <= '0';
        else
          axi_wready <= '0';
        end if;
      end if;
    end if;
  end process write_data_proc;

  ----------------------------------------------------------------------------
  -- Register Write Control
  -- Generate write enable to register bank when both address and data received
  ----------------------------------------------------------------------------
  wr_en   <= write_txn.addr_received and write_txn.data_received;
  wr_addr <= axi_awaddr;
  wr_data <= s_axi_wdata;
  wr_strb <= s_axi_wstrb;

  ----------------------------------------------------------------------------
  -- Write Response Logic
  ----------------------------------------------------------------------------
  write_response_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_bvalid <= '0';
        axi_bresp  <= C_RESP_OKAY;
      else
        if (write_txn.addr_received = '1' and write_txn.data_received = '1' and axi_bvalid = '0') then
          -- Both address and data received, assert write response
          axi_bvalid <= '1';
          axi_bresp  <= C_RESP_OKAY;
        elsif (s_axi_bready = '1' and axi_bvalid = '1') then
          -- Write response accepted by master
          axi_bvalid <= '0';
        end if;
      end if;
    end if;
  end process write_response_proc;

  ----------------------------------------------------------------------------
  -- Read Address Channel
  ----------------------------------------------------------------------------
  read_addr_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_arready <= '0';
        axi_araddr  <= (others => '0');
      else
        if (axi_arready = '0' and s_axi_arvalid = '1') then
          axi_arready <= '1';
          axi_araddr  <= s_axi_araddr;
        else
          axi_arready <= '0';
        end if;
      end if;
    end if;
  end process read_addr_proc;

  ----------------------------------------------------------------------------
  -- Register Read Control
  -- Trigger read from register bank when address is accepted
  ----------------------------------------------------------------------------
  rd_en   <= axi_arready and s_axi_arvalid and not axi_rvalid;
  rd_addr <= axi_araddr;

  ----------------------------------------------------------------------------
  -- Read Valid Generation
  -- Assert RVALID when register bank provides valid read data
  ----------------------------------------------------------------------------
  read_valid_proc : process (clk) is
  begin
    if rising_edge(clk) then
      if rst = '1' then
        axi_rvalid <= '0';
        axi_rresp  <= C_RESP_OKAY;
        axi_rdata  <= (others => '0');
      else
        if rd_valid = '1' then
          -- Register bank has valid data
          axi_rvalid <= '1';
          axi_rresp  <= C_RESP_OKAY;
          axi_rdata  <= rd_data;
        elsif (axi_rvalid = '1' and s_axi_rready = '1') then
          -- Master accepted read data
          axi_rvalid <= '0';
        end if;
      end if;
    end if;
  end process read_valid_proc;

end architecture rtl;