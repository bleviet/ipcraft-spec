

--------------------------------------------------------------------------------
-- Package: led_controller_pkg
-- Generated by ipcore_lib VHDL Generator
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package led_controller_pkg is

  ----------------------------------------------------------------------------
  -- Constants
  ----------------------------------------------------------------------------
  constant C_DATA_WIDTH : natural := 32;
  constant C_ADDR_WIDTH : natural := 8;
  constant C_REG_WIDTH  : natural := 4;  -- Bytes per register

  ----------------------------------------------------------------------------
  -- Register Enumeration (Order defines address)
  ----------------------------------------------------------------------------
  type t_reg_id is (
    REG_CONTROL,  -- addr 00
    REG_STATUS,  -- addr 04
    REG_LED_OUTPUT  -- addr 08
  );

  -- Calculate register address from enumeration
  function reg_addr(reg : t_reg_id) return natural;

  ----------------------------------------------------------------------------
  -- Register Record Types
  ----------------------------------------------------------------------------

  -- CONTROL register fields
  type t_reg_control is record
    enable : std_logic;  -- bit 0
    pwm_enable : std_logic;  -- bit 1
    blink_enable : std_logic;  -- bit 2
    irq_enable : std_logic;  -- bit 3
    reserved : std_logic_vector(27 downto 0);  -- bits 31:4
  end record;

  constant C_REG_CONTROL_RESET : t_reg_control := (
    enable => '0',
    pwm_enable => '0',
    blink_enable => '0',
    irq_enable => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_control) return std_logic_vector;
  function to_control(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_control;

  -- STATUS register fields
  type t_reg_status is record
    ready : std_logic;  -- bit 0
    error : std_logic;  -- bit 1
    reserved : std_logic_vector(29 downto 0);  -- bits 31:2
  end record;

  constant C_REG_STATUS_RESET : t_reg_status := (
    ready => '0',
    error => '0',
    reserved => (others => '0')
  );

  function to_slv(reg : t_reg_status) return std_logic_vector;
  function to_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_status;

  -- LED_OUTPUT register fields
  type t_reg_led_output is record
    led_state : std_logic_vector(31 downto 0);  -- bits 31:0
  end record;

  constant C_REG_LED_OUTPUT_RESET : t_reg_led_output := (
    led_state => (others => '0')
  );

  function to_slv(reg : t_reg_led_output) return std_logic_vector;
  function to_led_output(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_led_output;

  ----------------------------------------------------------------------------
  -- Aggregate Register Records (for clean port interface)
  ----------------------------------------------------------------------------

  -- SW -> HW: Registers written by software, read by hardware
  type t_regs_sw2hw is record
    control : t_reg_control;
    led_output : t_reg_led_output;
  end record;

  constant C_REGS_SW2HW_RESET : t_regs_sw2hw := (
    control => C_REG_CONTROL_RESET,
    led_output => C_REG_LED_OUTPUT_RESET
  );

  -- HW -> SW: Registers written by hardware, read by software
  type t_regs_hw2sw is record
    status : t_reg_status;
  end record;

  constant C_REGS_HW2SW_RESET : t_regs_hw2sw := (
    status => C_REG_STATUS_RESET
  );

end package led_controller_pkg;


package body led_controller_pkg is

  ----------------------------------------------------------------------------
  -- Register Address Function
  ----------------------------------------------------------------------------
  function reg_addr(reg : t_reg_id) return natural is
  begin
    return t_reg_id'pos(reg) * C_REG_WIDTH;
  end function;

  ----------------------------------------------------------------------------
  -- Conversion Functions
  ----------------------------------------------------------------------------

  -- CONTROL conversions
  function to_slv(reg : t_reg_control) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.enable;
    slv(1) := reg.pwm_enable;
    slv(2) := reg.blink_enable;
    slv(3) := reg.irq_enable;
    slv(31 downto 4) := reg.reserved;
    return slv;
  end function;

  function to_control(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_control is
    variable reg : t_reg_control;
  begin
    reg.enable := slv(0);
    reg.pwm_enable := slv(1);
    reg.blink_enable := slv(2);
    reg.irq_enable := slv(3);
    reg.reserved := slv(31 downto 4);
    return reg;
  end function;

  -- STATUS conversions
  function to_slv(reg : t_reg_status) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(0) := reg.ready;
    slv(1) := reg.error;
    slv(31 downto 2) := reg.reserved;
    return slv;
  end function;

  function to_status(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_status is
    variable reg : t_reg_status;
  begin
    reg.ready := slv(0);
    reg.error := slv(1);
    reg.reserved := slv(31 downto 2);
    return reg;
  end function;

  -- LED_OUTPUT conversions
  function to_slv(reg : t_reg_led_output) return std_logic_vector is
    variable slv : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
  begin
    slv(31 downto 0) := reg.led_state;
    return slv;
  end function;

  function to_led_output(slv : std_logic_vector(C_DATA_WIDTH-1 downto 0)) return t_reg_led_output is
    variable reg : t_reg_led_output;
  begin
    reg.led_state := slv(31 downto 0);
    return reg;
  end function;

end package body led_controller_pkg;
