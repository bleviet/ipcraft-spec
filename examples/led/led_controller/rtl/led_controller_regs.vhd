


--------------------------------------------------------------------------------
-- Entity: led_controller_regs
-- Description: Register bank with software/hardware access interface
-- Generated by ipcore_lib VHDL Generator
--
-- This is a bus-agnostic register bank that provides:
-- - Register storage for SW-writable registers
-- - Pulse generation for write-1-to-clear fields
-- - Clean interface for hardware logic access
--
-- Connect to a bus wrapper (AXI-Lite, Avalon-MM, etc.) for host access.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.led_controller_pkg.all;

entity led_controller_regs is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;

    -- Write interface (from bus wrapper)
    wr_en   : in  std_logic;
    wr_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    wr_data : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wr_strb : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);

    -- Read interface (from bus wrapper)
    rd_en   : in  std_logic;
    rd_addr : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    rd_data : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    rd_valid: out std_logic;

    -- Register interface to core logic
    regs_out : out t_regs_sw2hw;  -- SW-writable registers (to core)
    regs_in  : in  t_regs_hw2sw   -- HW-writable registers (from core)
  );
end entity led_controller_regs;

architecture rtl of led_controller_regs is

  -- Internal register storage
  signal regs : t_regs_sw2hw := C_REGS_SW2HW_RESET;

  -- Read data pipeline
  signal rd_data_int  : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal rd_valid_int : std_logic;

  -- Apply write strobe to data
  function apply_wstrb(
    old_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    new_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wstrb    : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0)
  ) return std_logic_vector is
    variable result : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    for i in 0 to (C_DATA_WIDTH/8)-1 loop
      if wstrb(i) = '1' then
        result(i*8+7 downto i*8) := new_data(i*8+7 downto i*8);
      else
        result(i*8+7 downto i*8) := old_data(i*8+7 downto i*8);
      end if;
    end loop;
    return result;
  end function;

begin

  -- Output register values to core
  regs_out <= regs;
  rd_data  <= rd_data_int;
  rd_valid <= rd_valid_int;

  ----------------------------------------------------------------------------
  -- Write Process
  ----------------------------------------------------------------------------
  p_write : process(clk)
    variable v_addr_index : natural;
    variable v_wdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    if rising_edge(clk) then
      if rst = '1' then
        regs <= C_REGS_SW2HW_RESET;
      elsif wr_en = '1' then
        v_addr_index := to_integer(unsigned(wr_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
          when t_reg_id'pos(REG_CONTROL) =>
            v_wdata := apply_wstrb(to_slv(regs.control), wr_data, wr_strb);
            regs.control <= to_control(v_wdata);
          when t_reg_id'pos(REG_LED_OUTPUT) =>
            v_wdata := apply_wstrb(to_slv(regs.led_output), wr_data, wr_strb);
            regs.led_output <= to_led_output(v_wdata);
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;

  ----------------------------------------------------------------------------
  -- Read Process
  ----------------------------------------------------------------------------
  p_read : process(clk)
    variable v_addr_index : natural;
  begin
    if rising_edge(clk) then
      rd_valid_int <= '0';

      if rst = '1' then
        rd_data_int  <= (others => '0');
        rd_valid_int <= '0';
      elsif rd_en = '1' then
        v_addr_index := to_integer(unsigned(rd_addr(C_ADDR_WIDTH-1 downto 2)));

        case v_addr_index is
          when t_reg_id'pos(REG_CONTROL) =>
            rd_data_int <= to_slv(regs.control);
          when t_reg_id'pos(REG_STATUS) =>
            rd_data_int <= to_slv(regs_in.status);
          when t_reg_id'pos(REG_LED_OUTPUT) =>
            rd_data_int <= to_slv(regs.led_output);
          when others =>
            rd_data_int <= (others => '0');
        end case;

        rd_valid_int <= '1';
      end if;
    end if;
  end process;

end architecture rtl;
